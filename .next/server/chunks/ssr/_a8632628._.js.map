{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/services/colombian-holidays.ts"],"sourcesContent":["/**\n * Representa una fecha.\n */\nexport interface Date {\n  year: number;\n  month: number; // 1-12\n  day: number;\n}\n\n/**\n * Obtiene de forma asíncrona una lista de festivos colombianos para un año dado.\n *\n * @param year El año para el cual obtener los festivos.\n * @returns Una promesa que resuelve a un array de objetos Date representando los festivos.\n */\nexport async function getColombianHolidays(year: number): Promise<Date[]> {\n  // TODO: Implementar esto llamando a una API externa o usando una biblioteca confiable.\n  // Ejemplo de estructura placeholder:\n  // const response = await fetch(`https://api.example.com/holidays/co/${year}`);\n  // if (!response.ok) {\n  //   throw new Error('Fallo al obtener los festivos');\n  // }\n  // const holidays = await response.json();\n  // return holidays.map(holiday => ({ year: year, month: ..., day: ... }));\n\n   console.warn(`Obteniendo festivos para ${year} - Usando datos de ejemplo. Implementar llamada API.`);\n\n   // Datos de ejemplo SOLO para desarrollo/pruebas\n   if (year === 2024) {\n        return [\n            { year: 2024, month: 1, day: 1 }, { year: 2024, month: 1, day: 8 }, // Año Nuevo, Reyes Magos\n            { year: 2024, month: 3, day: 25 }, { year: 2024, month: 3, day: 28 }, // San José, Jueves Santo\n            { year: 2024, month: 3, day: 29 }, { year: 2024, month: 5, day: 1 }, // Viernes Santo, Día del Trabajo\n            { year: 2024, month: 5, day: 13 }, { year: 2024, month: 6, day: 3 }, // Ascensión del Señor, Corpus Christi\n            { year: 2024, month: 6, day: 10 }, { year: 2024, month: 7, day: 1 }, // Sagrado Corazón, San Pedro y San Pablo\n            { year: 2024, month: 7, day: 20 }, { year: 2024, month: 8, day: 7 }, // Independencia, Batalla de Boyacá\n            { year: 2024, month: 8, day: 19 }, { year: 2024, month: 10, day: 14 }, // Asunción de la Virgen, Día de la Raza\n            { year: 2024, month: 11, day: 4 }, { year: 2024, month: 11, day: 11 }, // Todos los Santos, Independencia de Cartagena\n            { year: 2024, month: 12, day: 8 }, { year: 2024, month: 12, day: 25 } // Inmaculada Concepción, Navidad\n        ];\n   }\n   if (year === 2025) {\n     return [\n       { year: 2025, month: 1, day: 1 }, { year: 2025, month: 1, day: 6 }, // Año Nuevo, Reyes Magos\n       { year: 2025, month: 3, day: 24 }, { year: 2025, month: 4, day: 17 }, // San José, Jueves Santo\n       { year: 2025, month: 4, day: 18 }, { year: 2025, month: 5, day: 1 }, // Viernes Santo, Día del Trabajo\n       { year: 2025, month: 6, day: 2 }, { year: 2025, month: 6, day: 23 }, // Ascensión del Señor, Corpus Christi\n       { year: 2025, month: 6, day: 30 }, { year: 2025, month: 7, day: 20 }, // Sagrado Corazón, San Pedro y San Pablo (Nota: 20 Julio cae Domingo, no se traslada)\n       { year: 2025, month: 8, day: 7 }, { year: 2025, month: 8, day: 18 }, // Batalla de Boyacá, Asunción de la Virgen\n       { year: 2025, month: 10, day: 13 }, { year: 2025, month: 11, day: 3 }, // Día de la Raza, Todos los Santos\n       { year: 2025, month: 11, day: 17 }, { year: 2025, month: 12, day: 8 }, // Independencia de Cartagena, Inmaculada Concepción\n       { year: 2025, month: 12, day: 25 } // Navidad\n     ];\n   }\n    if (year === 2023) {\n        return [\n            { year: 2023, month: 1, day: 1 }, { year: 2023, month: 1, day: 9 },\n            { year: 2023, month: 3, day: 20 }, { year: 2023, month: 4, day: 6 },\n            { year: 2023, month: 4, day: 7 }, { year: 2023, month: 5, day: 1 },\n            { year: 2023, month: 5, day: 22 }, { year: 2023, month: 6, day: 12 },\n            { year: 2023, month: 6, day: 19 }, { year: 2023, month: 7, day: 3 },\n            { year: 2023, month: 7, day: 20 }, { year: 2023, month: 8, day: 7 },\n            { year: 2023, month: 8, day: 21 }, { year: 2023, month: 10, day: 16 },\n            { year: 2023, month: 11, day: 6 }, { year: 2023, month: 11, day: 13 },\n            { year: 2023, month: 12, day: 8 }, { year: 2023, month: 12, day: 25 }\n        ];\n    }\n\n\n  // Retorna array vacío si no hay datos de ejemplo o la API falla en el futuro\n  return [];\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/actions/calculate-workday.ts"],"sourcesContent":["\n'use server';\n\nimport {\n    parse, format, addHours, addDays,\n    isBefore, isAfter, isEqual, isSameDay,\n    startOfDay, endOfDay, getDay, getHours, getMinutes,\n    differenceInSeconds, setHours, setMinutes, setSeconds, setMilliseconds,\n    isValid, getYear\n} from 'date-fns';\nimport type { z } from 'zod';\nimport type { WorkdayFormValues } from '@/components/workday-form'; // Adjust path if needed\nimport type { CalculationResults, CalculationError } from '@/types';\nimport { getColombianHolidays } from '@/services/colombian-holidays';\n\n\n// --- Constantes y Parámetros ---\nconst HORAS_JORNADA_BASE = 7.66; // Horas base antes de considerar extras\nconst HORA_NOCTURNA_INICIO = 21; // 9 PM (inclusive)\nconst HORA_NOCTURNA_FIN = 6;   // 6 AM (exclusive)\n\n// Valores por hora (pesos colombianos)\n// ESTE ES EL OBJETO QUE DEBES ACTUALIZAR SI LOS VALORES CAMBIAN:\nexport const VALORES = { // Export this constant\n    \"Recargo_Noct_Base\": 2166,          // Recargo Nocturno (dentro de las 7.66h base, laboral)\n    \"HED\": 7736.41,                        // Hora Extra Diurna (después de 7.66h,laboral, hasta las 9 pm )\n    \"HEN\": 10830.98,                        // Hora Extra Nocturna (después de 7.66h, laboral)\n    \"Recargo_Dom_Diurno_Base\": 4642,    // Recargo Dominical/Festivo Diurno (dentro de 7.66h)\n    \"Recargo_Dom_Noct_Base\": 6808,    // Recargo Dominical/Festivo Nocturno (dentro de 7.66h)\n    \"HEDD_F\": 12378.26,                     // Hora Extra Dominical/Festiva Diurna (después de 7.66h)\n    \"HEND_F\": 15472.83,                     // Hora Extra Dominical/Festiva Nocturna (después de 7.66h)\n    \"Ordinaria_Diurna_Base\": 0          // Horas base diurnas laborales (sin recargo adicional sobre el salario)\n};\n// const SALARIO_BASE_QUINCENAL = 711750; // Salario base quincenal will be handled at the summary level\n\n// Cache para festivos\nlet festivosCache: { [year: number]: Set<string> } = {};\n\nasync function getFestivosSet(year: number): Promise<Set<string>> {\n    if (festivosCache[year]) {\n        return festivosCache[year];\n    }\n    try {\n        const holidays = await getColombianHolidays(year);\n        // Ensure holidays is an array before mapping\n        if (!Array.isArray(holidays)) {\n             console.error(`Error: getColombianHolidays(${year}) did not return an array.`);\n             throw new Error(`Formato de respuesta inválido para festivos de ${year}.`);\n        }\n        const festivosSet = new Set(holidays.map(h => {\n             // Add validation for holiday object structure if needed\n             if (!h || typeof h.year !== 'number' || typeof h.month !== 'number' || typeof h.day !== 'number') {\n                 console.error(`Error: Invalid holiday object structure for year ${year}:`, h);\n                 // Depending on strictness, you might throw or just skip this entry\n                 // throw new Error(`Estructura de festivo inválida.`);\n                 return ''; // Skip invalid entry if Set creation handles empty strings ok\n             }\n             try {\n                // Validate date components before formatting\n                const dateToFormat = new Date(h.year, h.month - 1, h.day);\n                if (!isValid(dateToFormat) || getYear(dateToFormat) !== h.year) {\n                    console.error(`Error: Invalid date components for holiday in year ${year}:`, h);\n                    return ''; // Skip invalid date\n                }\n                return format(dateToFormat, 'yyyy-MM-dd');\n             } catch (formatError) {\n                 console.error(`Error formatting holiday date for year ${year}:`, h, formatError);\n                 return ''; // Skip on formatting error\n             }\n        }));\n        // Filter out any empty strings added due to errors\n        const validFestivosSet = new Set(Array.from(festivosSet).filter(dateStr => dateStr !== ''));\n        festivosCache[year] = validFestivosSet;\n        return validFestivosSet;\n    } catch (error) {\n        console.error(`Error al obtener o procesar festivos para ${year}:`, error);\n        // Re-lanzar el error para que sea capturado por el try-catch principal\n        // Provide a more user-friendly message if possible, or keep technical detail for logs\n        const userMessage = `Error consultando/procesando festivos para ${year}. Verifique la fuente de datos.`;\n        throw new Error(userMessage + ` Detalle: ${error instanceof Error ? error.message : String(error)}`);\n    }\n}\n\n\nasync function esFestivo(fecha: Date): Promise<boolean> {\n    const year = getYear(fecha);\n    try {\n        const festivos = await getFestivosSet(year); // Can throw if getFestivosSet fails\n        const fechaStr = format(fecha, 'yyyy-MM-dd');\n        return festivos.has(fechaStr);\n    } catch (error) {\n        // Log the specific error and re-throw to be caught by the main handler\n        console.error(`Error checking if date ${format(fecha, 'yyyy-MM-dd')} is a holiday:`, error);\n        throw error; // Re-throw the original error (which should include details from getFestivosSet)\n    }\n}\n\nfunction esDominical(fecha: Date): boolean {\n    return getDay(fecha) === 0; // 0 = Domingo\n}\n\n// Helper to parse HH:mm time string into hours and minutes\nfunction parseTimeString(timeStr: string | undefined): { hours: number; minutes: number } | null {\n    if (!timeStr || !/^\\d{2}:\\d{2}$/.test(timeStr)) return null;\n    const [hours, minutes] = timeStr.split(':').map(Number);\n    return { hours, minutes };\n}\n\n\n// --- Lógica Principal de Cálculo ---\n// Returns calculation for a SINGLE workday\nexport async function calculateSingleWorkday(\n    values: WorkdayFormValues,\n    id: string // Pass the unique ID for this calculation\n): Promise<CalculationResults | CalculationError> {\n\n    try { // <--- Start of main try block\n        const { startDate, startTime, endTime, endsNextDay, includeBreak, breakStartTime, breakEndTime } = values;\n\n        // --- Parseo y Validación Inicial ---\n        const inicioDtStr = `${format(startDate, 'yyyy-MM-dd')} ${startTime}`;\n        const inicioDt = parse(inicioDtStr, 'yyyy-MM-dd HH:mm', new Date());\n\n        if (!isValid(inicioDt)) {\n            return { error: `ID ${id}: Fecha u hora de inicio inválida.` };\n        }\n\n        let finDt: Date;\n        let finDtStr = `${format(startDate, 'yyyy-MM-dd')} ${endTime}`;\n        if (endsNextDay) {\n            finDtStr = `${format(addDays(startDate, 1), 'yyyy-MM-dd')} ${endTime}`;\n        }\n        finDt = parse(finDtStr, 'yyyy-MM-dd HH:mm', new Date());\n\n\n        if (!isValid(finDt)) {\n            return { error: `ID ${id}: Fecha u hora de fin inválida.` };\n        }\n\n        if (isBefore(finDt, inicioDt) || isEqual(finDt, inicioDt)) {\n            return { error: `ID ${id}: La hora de fin debe ser posterior a la hora de inicio.` };\n        }\n\n        // --- Validar y parsear horas de descanso si aplica ---\n        let parsedBreakStart: { hours: number; minutes: number } | null = null;\n        let parsedBreakEnd: { hours: number; minutes: number } | null = null;\n        let breakDurationSeconds = 0; // Initialize break duration\n\n        if (includeBreak) {\n            parsedBreakStart = parseTimeString(breakStartTime);\n            parsedBreakEnd = parseTimeString(breakEndTime);\n\n            if (!parsedBreakStart || !parsedBreakEnd) {\n                 return { error: `ID ${id}: Formato de hora de descanso inválido (HH:mm).` };\n            }\n            // Break end time check moved to form validation, but keep a basic check here maybe?\n            // if (parsedBreakEnd.hours < parsedBreakStart.hours || (parsedBreakEnd.hours === parsedBreakStart.hours && parsedBreakEnd.minutes <= parsedBreakStart.minutes)) {\n            //      return { error: `ID ${id}: La hora de fin del descanso debe ser posterior a la hora de inicio.` };\n            // }\n\n             // Calculate break duration in seconds ONLY if valid times were parsed\n             const breakStartTotalMinutes = parsedBreakStart.hours * 60 + parsedBreakStart.minutes;\n             const breakEndTotalMinutes = parsedBreakEnd.hours * 60 + parsedBreakEnd.minutes;\n             // Check again if end is after start before calculating duration\n             if (breakEndTotalMinutes > breakStartTotalMinutes) {\n                breakDurationSeconds = (breakEndTotalMinutes - breakStartTotalMinutes) * 60;\n             } else {\n                 // This case should ideally be caught by form validation, but as a fallback:\n                 console.warn(`ID ${id}: Hora de fin de descanso no es posterior a la de inicio, ignorando descanso.`);\n                 breakDurationSeconds = 0;\n                 // Optionally return an error instead:\n                 // return { error: `ID ${id}: La hora de fin del descanso debe ser posterior a la hora de inicio.` };\n             }\n\n        }\n\n\n        // --- Obtener Festivos para los años involucrados ---\n        // This will throw if getFestivosSet fails internally\n        await getFestivosSet(getYear(inicioDt));\n        if (!isSameDay(inicioDt, finDt)) {\n            await getFestivosSet(getYear(finDt));\n        }\n\n\n        // --- Inicializar contadores ---\n        let horasClasificadas: CalculationResults['horasDetalladas'] = {\n            \"Ordinaria_Diurna_Base\": 0.0,\n            \"Recargo_Noct_Base\": 0.0,\n            \"Recargo_Dom_Diurno_Base\": 0.0,\n            \"Recargo_Dom_Noct_Base\": 0.0,\n            \"HED\": 0.0,\n            \"HEN\": 0.0,\n            \"HEDD_F\": 0.0,\n            \"HEND_F\": 0.0\n        };\n        let duracionTotalSegundosBrutos = differenceInSeconds(finDt, inicioDt);\n        let duracionTotalTrabajadaSegundos = 0; // Calculate based on iteration below\n\n        // let duracionTotalTrabajadaSegundos = duracionTotalSegundosBrutos - (includeBreak ? breakDurationSeconds : 0);\n        // if (duracionTotalTrabajadaSegundos < 0) duracionTotalTrabajadaSegundos = 0; // Ensure it doesn't go negative\n\n        let segundosTrabajadosAcumulados = 0; // To track the extra hours threshold\n\n        // --- Iterar minuto a minuto sobre el tiempo BRUTO (antes de descontar descanso) ---\n        let cursorDt = inicioDt;\n\n        while (isBefore(cursorDt, finDt)) {\n            const cursorPlusOneMin = addHours(cursorDt, 1 / 60); // Siguiente minuto\n\n            // Punto medio del intervalo de 1 minuto para evaluar condiciones\n            const puntoEvaluacion = addHours(cursorDt, 1 / 120); // +30 segundos\n            const horaEval = getHours(puntoEvaluacion);\n            const minutoEval = getMinutes(puntoEvaluacion); // Necesario para descansos precisos\n\n            // Verificar si es Descanso usando los tiempos parseados si includeBreak es true y times are valid\n            let esDescanso = false;\n            if (includeBreak && parsedBreakStart && parsedBreakEnd && breakDurationSeconds > 0) { // Only check if break times were valid\n                 const horaActualTotalMinutos = horaEval * 60 + minutoEval;\n                 const inicioDescansoTotalMinutos = parsedBreakStart.hours * 60 + parsedBreakStart.minutes;\n                 const finDescansoTotalMinutos = parsedBreakEnd.hours * 60 + parsedBreakEnd.minutes;\n\n                 // El descanso es inclusivo en el inicio y exclusivo en el fin\n                 esDescanso = horaActualTotalMinutos >= inicioDescansoTotalMinutos && horaActualTotalMinutos < finDescansoTotalMinutos;\n            }\n\n            if (!esDescanso) {\n                // Solo clasificar y acumular si NO es descanso\n                duracionTotalTrabajadaSegundos += 60; // Sumar segundos efectivamente trabajados\n                segundosTrabajadosAcumulados += 60; // Sumar un minuto efectivamente trabajado\n                const horasTrabajadasAcumuladas = segundosTrabajadosAcumulados / 3600.0;\n                const esHoraExtra = horasTrabajadasAcumuladas > HORAS_JORNADA_BASE;\n                // The call to esFestivo is within the try-catch; if it fails, it will be caught.\n                const esFestivoDominical = await esFestivo(puntoEvaluacion) || esDominical(puntoEvaluacion);\n                const esNocturna = horaEval >= HORA_NOCTURNA_INICIO || horaEval < HORA_NOCTURNA_FIN;\n\n                // --- Clasificación del minuto ---\n                let categoria: keyof typeof horasClasificadas | null = null;\n\n                if (esHoraExtra) {\n                    if (esFestivoDominical) {\n                        categoria = esNocturna ? \"HEND_F\" : \"HEDD_F\";\n                    } else {\n                        categoria = esNocturna ? \"HEN\" : \"HED\";\n                    }\n                } else { // Dentro de la jornada base\n                    if (esFestivoDominical) {\n                        categoria = esNocturna ? \"Recargo_Dom_Noct_Base\" : \"Recargo_Dom_Diurno_Base\";\n                    } else { // Día laboral\n                        if (esNocturna) {\n                            categoria = \"Recargo_Noct_Base\";\n                        } else {\n                             // Para las horas base diurnas, no sumamos recargo, pero sí contamos las horas.\n                             horasClasificadas[\"Ordinaria_Diurna_Base\"] += 1 / 60;\n                             // No asignamos categoría para no sumar recargo de VALORES[\"Ordinaria_Diurna_Base\"] que es 0\n                        }\n                    }\n                }\n\n                // Sumar el minuto a la categoría correspondiente (si no es Ordinaria_Diurna_Base)\n                if (categoria && categoria !== \"Ordinaria_Diurna_Base\") {\n                    horasClasificadas[categoria] += 1 / 60;\n                }\n            }\n\n            cursorDt = cursorPlusOneMin; // Avanzar al siguiente minuto\n        }\n\n         // --- Calcular Pagos ---\n         let pagoTotalRecargosExtras = 0;\n         const pagoDetallado: { [key: string]: number } = {};\n\n         for (const key in horasClasificadas) {\n             const horas = horasClasificadas[key as keyof typeof horasClasificadas];\n             if (horas > 0) {\n                  const valorHora = VALORES[key as keyof typeof VALORES] ?? 0; // Usar VALORES directos\n                  // Agregar validación por si acaso VALORES no tuviera una clave esperada\n                  if (valorHora === undefined && key !== \"Ordinaria_Diurna_Base\") {\n                       console.warn(`ID ${id}: No se encontró valor para la categoría '${key}' en VALORES.`);\n                       // Podrías lanzar un error aquí si es crítico\n                       // throw new Error(`ID ${id}: Configuración de VALORES incompleta. Falta '${key}'.`);\n                  }\n                  // Calculate payment only for surcharges/extras, not base hours\n                  if (key !== \"Ordinaria_Diurna_Base\") {\n                    const pagoCategoria = horas * (valorHora ?? 0);\n                    pagoTotalRecargosExtras += pagoCategoria;\n                    pagoDetallado[key] = pagoCategoria;\n                  } else {\n                     pagoDetallado[key] = 0; // Base diurnal hours have 0 extra payment\n                  }\n\n             } else {\n                pagoDetallado[key] = 0; // Asegurar que todas las claves existan en el resultado\n             }\n         }\n\n\n        // No sumar el salario base aquí, se hará en el resumen quincenal\n        // const pagoTotalConSalario = pagoTotalRecargosExtras + SALARIO_BASE_QUINCENAL;\n\n        // --- Retornar Resultados ---\n        return {\n            id: id, // Include the ID in the result\n            inputData: values, // Store the input data used\n            horasDetalladas: horasClasificadas,\n            pagoDetallado: pagoDetallado,\n            pagoTotalRecargosExtras: pagoTotalRecargosExtras, // Only extras/surcharges for this day\n            pagoTotalConSalario: pagoTotalRecargosExtras, // Represents only the extra pay for the day, not total daily salary\n            duracionTotalTrabajadaHoras: duracionTotalTrabajadaSegundos / 3600.0, // Include actual worked duration for the day\n        };\n\n    } catch (error) { // <--- Catch block for the main try\n        console.error(`ID ${id}: Error inesperado durante el cálculo:`, error);\n        // Return a CalculationError object with a specific or generic message\n        // Include the ID in the error message for better tracking\n        const errorMessage = `ID ${id}: Error inesperado durante el cálculo. ${error instanceof Error ? error.message : String(error)}`;\n        return {\n            error: errorMessage // Return the detailed error message\n        };\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 613, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 667, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","debugId":null}},
    {"offset": {"line": 681, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgQ,GAC7R,8BACA","debugId":null}},
    {"offset": {"line": 695, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}